<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VisualRiskAssessor - HSE Risk Assessment</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
  <style>
    :root { --p:#ff6d00; --s:#1565c0; --ok:#4caf50; --mid:#ffc107; --hi:#f44336; --x:#b71c1c; }
    * { box-sizing:border-box; }
    body { margin:0; font-family:Segoe UI,Roboto,Arial,sans-serif; background:#f5f5f5; color:#212121; }
    .header { background:linear-gradient(120deg,#ff6d00,#e65100); color:#fff; text-align:center; padding:20px 12px; }
    .container { max-width:980px; margin:0 auto; padding:16px; }
    .card { background:#fff; border-radius:14px; padding:18px; margin-bottom:16px; box-shadow:0 2px 10px rgba(0,0,0,.08); }
    .btn { border:none; border-radius:10px; padding:12px 16px; font-weight:600; cursor:pointer; }
    .btn + .btn { margin-left:8px; }
    .btn-primary { background:var(--p); color:#fff; }
    .btn-secondary { background:var(--s); color:#fff; }
    .btn-outline { background:#fff; color:var(--s); border:2px solid var(--s); }
    .hidden { display:none !important; }
    #uploadArea { border:2px dashed var(--s); border-radius:10px; padding:20px; margin-top:12px; background:#eef6ff; cursor:pointer; }
    #uploadArea:focus-visible { outline:3px solid #000; }
    #cameraSection { text-align:center; margin-top:12px; }
    #videoPreview,#resultImg { width:100%; max-width:620px; border-radius:10px; background:#000; }
    .warning { background:#fff3cd; color:#694f00; border-radius:8px; padding:10px; margin-bottom:10px; }
    .result-chip { display:inline-block; padding:6px 10px; border-radius:999px; color:#fff; font-weight:700; }
    .hazard-item { border-left:5px solid var(--mid); background:#fafafa; padding:10px; border-radius:8px; margin-bottom:8px; }
    .risk-low { border-left-color:var(--ok); }
    .risk-medium { border-left-color:var(--mid); }
    .risk-high { border-left-color:var(--hi); }
    .risk-extreme { border-left-color:var(--x); }
    .matrix { display:grid; grid-template-columns:42px repeat(5,1fr); gap:3px; max-width:450px; }
    .cell { min-height:36px; border-radius:5px; display:flex; align-items:center; justify-content:center; font-size:.8rem; font-weight:600; }
    .head { background:#1565c0; color:#fff; }
    .low { background:var(--ok); color:#fff; }
    .med { background:var(--mid); }
    .high { background:var(--hi); color:#fff; }
    .ext { background:var(--x); color:#fff; }
    .mark { outline:3px solid #000; }
    #loading { position:fixed; inset:0; background:rgba(0,0,0,.72); color:#fff; display:none; place-items:center; font-size:1.1rem; z-index:999; }
    #loading.active { display:grid; }
  </style>
</head>
<body>
  <header class="header">
    <h1 style="margin:0">VisualRiskAssessor</h1>
    <p style="margin:8px 0 0">GitHub Pages HSE visual risk tool</p>
  </header>

  <main class="container">
    <div id="envWarning" class="warning hidden" role="alert"></div>
    <div id="cameraStatus" class="warning hidden" role="status"></div>
    <div id="runtimeStatus" class="warning hidden" role="status"></div>
    <pre id="diagOutput" class="warning hidden" aria-live="polite" style="white-space:pre-wrap"></pre>

    <section id="inputSec" class="card">
      <h2 style="margin-top:0">Image Input</h2>
      <button class="btn btn-primary" id="btnCamera">ðŸ“· Open Camera</button>
      <select id="cameraSelect" class="btn btn-outline" aria-label="Select camera" style="margin-left:8px;">
        <option value="">Auto camera</option>
      </select>
      <button class="btn btn-outline" id="btnSwitchCam">Switch Camera</button>
      <button class="btn btn-outline" id="btnCameraBasic">Open Camera (Compat)</button>
      <button class="btn btn-outline" id="btnDiagnose">Run Diagnostics</button>
      <button class="btn btn-outline" id="btnCopyDiag">Copy Diagnostics</button>
      <button class="btn btn-secondary" id="btnUpload">ðŸ–¼ Upload Image</button>
      <input id="fileInput" type="file" accept="image/*,.heic,.heif" capture="environment" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;" />
      <div id="uploadArea" tabindex="0" role="button" aria-label="Upload an image">Click or press Enter/Space to upload an image.</div>

      <div id="cameraSection" class="hidden">
        <video id="videoPreview" autoplay playsinline muted></video><br/><br/>
        <button class="btn btn-primary" id="btnCapture">Capture</button>
        <button class="btn btn-outline" id="btnStop">Stop Camera</button>
      </div>
    </section>

    <section id="results" class="card hidden" aria-live="polite">
      <h2 style="margin-top:0">Assessment Results</h2>
      <div id="fallbackWarning" class="warning hidden">ML model unavailable. Showing heuristic risk estimation.</div>
      <img id="resultImg" alt="Analyzed image" />
      <p><strong>Overall Risk Score:</strong> <span id="overallScore">0</span></p>
      <p><strong>Risk Level:</strong> <span id="overallLevel" class="result-chip">Assessing...</span></p>
      <h3>Hazards</h3>
      <div id="hazardsList"></div>
      <h3>Risk Matrix</h3>
      <div id="riskMatrix" class="matrix"></div>
      <h3>Recommendations</h3>
      <div id="recsList"></div>
      <button class="btn btn-secondary" id="btnExport">Export Report</button>
      <button class="btn btn-outline" id="btnReset">New Assessment</button>
    </section>
  </main>

  <div id="loading" aria-live="assertive">Analyzing image...</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const els = {
    envWarning: $('envWarning'), cameraStatus: $('cameraStatus'), runtimeStatus: $('runtimeStatus'), results: $('results'), fileInput: $('fileInput'), uploadArea: $('uploadArea'),
    cameraSection: $('cameraSection'), videoPreview: $('videoPreview'), resultImg: $('resultImg'),
    overallScore: $('overallScore'), overallLevel: $('overallLevel'), hazardsList: $('hazardsList'), riskMatrix: $('riskMatrix'),
    recsList: $('recsList'), fallbackWarning: $('fallbackWarning'), loading: $('loading'),
    btnCamera: $('btnCamera'), btnUpload: $('btnUpload'), btnCapture: $('btnCapture'), btnStop: $('btnStop'), btnExport: $('btnExport'), btnReset: $('btnReset'),
    cameraSelect: $('cameraSelect'), btnSwitchCam: $('btnSwitchCam'), btnCameraBasic: $('btnCameraBasic'), btnDiagnose: $('btnDiagnose'), btnCopyDiag: $('btnCopyDiag'), diagOutput: $('diagOutput')
  };

  let model = null, stream = null, imageData = null, hazards = [], overall = 0, usedFallback = false;
  let selectedDeviceId = '';
  let preferredFacingMode = 'environment';

  const AppState = Object.freeze({
    IDLE: 'idle',
    REQUESTING_CAMERA: 'requesting_camera',
    CAMERA_READY: 'camera_ready',
    CAMERA_FAILED: 'camera_failed',
    PICKER_OPENING: 'picker_opening',
    IMAGE_SELECTED: 'image_selected',
    ANALYZING: 'analyzing',
    ANALYSIS_READY: 'analysis_ready',
    ANALYSIS_FAILED: 'analysis_failed'
  });
  let appState = AppState.IDLE;
  let lastDiagnostics = [];

  function setAppState(nextState, message = '') {
    appState = nextState;
    if (message) setRuntimeStatus(message);
  }

  const hazardDB = {
    electrical:{name:'Electrical Hazard',L:4,S:4,kw:['wire','cable','electric','plug'],recs:['Isolate energy sources and apply lockout/tagout','Inspect protection devices and grounding integrity','Use insulated tools and arc-rated PPE']},
    slip:{name:'Slip/Trip/Fall Hazard',L:4,S:3,kw:['floor','ground','wet','slippery'],recs:['Dry floor immediately','Use anti-slip signage']},
    machinery:{name:'Machinery Hazard',L:3,S:4,kw:['machine','equipment','tool','motor'],recs:['Install guarding','Apply lockout-tagout']},
    fire:{name:'Fire Hazard',L:3,S:5,kw:['fire','flame','gas','smoke'],recs:['Remove ignition sources','Keep extinguisher nearby']}
  };

  function showWarning(msg){ els.envWarning.textContent = msg; els.envWarning.classList.remove('hidden'); }

  function setDiagOutput(lines) {
    if (!lines || lines.length === 0) {
      els.diagOutput.classList.add('hidden');
      els.diagOutput.textContent = '';
      return;
    }
    lastDiagnostics = [...lines];
    els.diagOutput.textContent = lines.join('\n');
    els.diagOutput.classList.remove('hidden');
  }

  async function runDiagnostics() {
    const lines = [];
    lines.push(`State: ${appState}`);
    lines.push(`Origin: ${location.origin}`);
    lines.push(`Secure context: ${window.isSecureContext}`);
    lines.push(`Protocol: ${location.protocol}`);
    lines.push(`mediaDevices.getUserMedia: ${typeof navigator.mediaDevices?.getUserMedia}`);
    lines.push(`legacy getUserMedia: ${typeof (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia)}`);
    lines.push(`enumerateDevices: ${typeof navigator.mediaDevices?.enumerateDevices}`);
    lines.push(`file input present: ${!!els.fileInput}`);
    lines.push(`file input accept: ${els.fileInput?.getAttribute('accept') || ''}`);
    try {
      if (navigator.mediaDevices?.enumerateDevices) {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter((d) => d.kind === 'videoinput');
        lines.push(`video devices found: ${cams.length}`);
      }
    } catch (err) {
      lines.push(`enumerateDevices error: ${err?.name || 'Error'} ${err?.message || ''}`);
    }
    setDiagOutput(lines);
    setRuntimeStatus('Diagnostics completed. Copy the diagnostics output if support is needed.');
  }

  async function copyDiagnostics() {
    const content = (lastDiagnostics && lastDiagnostics.length > 0)
      ? lastDiagnostics.join('\n')
      : (els.diagOutput?.textContent || '').trim();
    if (!content) {
      setRuntimeStatus('No diagnostics to copy. Run Diagnostics first.');
      return;
    }
    try {
      if (navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(content);
      } else {
        const temp = document.createElement('textarea');
        temp.value = content;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        temp.remove();
      }
      setRuntimeStatus('Diagnostics copied to clipboard.');
    } catch (_) {
      setRuntimeStatus('Unable to copy automatically. Select and copy diagnostics manually.');
    }
  }

  function setCameraStatus(msg){ if(!msg){ els.cameraStatus.classList.add('hidden'); els.cameraStatus.textContent=''; return; } els.cameraStatus.textContent = msg; els.cameraStatus.classList.remove('hidden'); }
  function setRuntimeStatus(msg){ if(!msg){ els.runtimeStatus.classList.add('hidden'); els.runtimeStatus.textContent=''; return; } els.runtimeStatus.textContent = msg; els.runtimeStatus.classList.remove('hidden'); }
  function setLoading(v){ els.loading.classList.toggle('active', v); }
  function riskFor(score){ if(score<=5) return {label:'Low Risk', cls:'risk-low', color:'var(--ok)'}; if(score<=14) return {label:'Medium Risk', cls:'risk-medium', color:'var(--mid)'}; if(score<=19) return {label:'High Risk', cls:'risk-high', color:'var(--hi)'}; return {label:'Extreme Risk', cls:'risk-extreme', color:'var(--x)'}; }

  async function initModel(){
    if (location.protocol === 'http:' && !['localhost','127.0.0.1'].includes(location.hostname)) {
      showWarning('Use HTTPS on GitHub Pages for camera access. Upload still works.');
      setRuntimeStatus('Camera will be blocked on insecure HTTP origins. Use https://<user>.github.io/...');
    }
    try { model = await mobilenet.load(); }
    catch { usedFallback = true; showWarning('ML model failed to load. Using heuristic analysis.'); }
  }

  async function refreshCameraOptions() {
    if (!navigator.mediaDevices?.enumerateDevices || !els.cameraSelect) return;
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter((d) => d.kind === 'videoinput');
      const current = els.cameraSelect.value;
      els.cameraSelect.textContent = '';
      const auto = document.createElement('option');
      auto.value = '';
      auto.textContent = 'Auto camera';
      els.cameraSelect.appendChild(auto);
      cams.forEach((cam, idx) => {
        const opt = document.createElement('option');
        opt.value = cam.deviceId;
        opt.textContent = cam.label || `Camera ${idx + 1}`;
        els.cameraSelect.appendChild(opt);
      });
      els.cameraSelect.value = cams.some(c => c.deviceId === current) ? current : '';
      selectedDeviceId = els.cameraSelect.value;
    } catch (_) {}
  }

  async function waitForVideoFrame(video, timeoutMs = 3000) {
    const start = Date.now();
    return new Promise((resolve) => {
      function check() {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
          resolve(true);
          return;
        }
        if (Date.now() - start >= timeoutMs) {
          resolve(false);
          return;
        }
        requestAnimationFrame(check);
      }
      check();
    });
  }

  // CAMERA_STABILITY_LOCK: Critical camera compatibility path. Do not simplify/remove without cross-device validation (Android, iOS, desktop).
  // CAMERA_STATE_LOCK: Keep AppState transitions deterministic for camera/upload/analyze actions.


  function isStreamUsable(mediaStream) {
    const track = mediaStream?.getVideoTracks?.()[0];
    return !!track && track.readyState === 'live' && track.enabled !== false;
  }

  async function waitForPlayable(video, timeoutMs = 3500) {
    const start = Date.now();
    return new Promise((resolve) => {
      const done = () => cleanup(true);
      const cleanup = (ok) => {
        video.removeEventListener('playing', done);
        video.removeEventListener('canplay', done);
        resolve(ok);
      };
      video.addEventListener('playing', done, { once: true });
      video.addEventListener('canplay', done, { once: true });
      (function check(){
        if (video.readyState >= 2) return cleanup(true);
        if (Date.now()-start >= timeoutMs) return cleanup(false);
        requestAnimationFrame(check);
      })();
    });
  }
  async function startCamera(options = {}){
    if (appState === AppState.REQUESTING_CAMERA || appState === AppState.ANALYZING) {
      setRuntimeStatus('Please wait for the current action to finish.');
      return;
    }
    stopCamera();
    setAppState(AppState.REQUESTING_CAMERA, 'Starting camera initialization...');

    const legacyGetUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    if (!navigator.mediaDevices?.getUserMedia && !legacyGetUserMedia) {
      showWarning('Camera API is not available in this browser. Please use Upload Image.');
      setAppState(AppState.CAMERA_FAILED, 'Camera API unavailable. Use Upload Image.');
      return;
    }

    setCameraStatus('Opening camera...');

    const attempts = options.forceBasic
      ? [{ video: true, audio: false }]
      : selectedDeviceId
      ? [
          { video: { deviceId: { exact: selectedDeviceId } }, audio: false },
          { video: { deviceId: selectedDeviceId }, audio: false },
          { video: true, audio: false }
        ]
      : [
          { video: true, audio: false },
          { video: { facingMode: { ideal: preferredFacingMode } }, audio: false },
          { video: { facingMode: preferredFacingMode }, audio: false },
          { video: { facingMode: { ideal: preferredFacingMode === 'environment' ? 'user' : 'environment' } }, audio: false }
        ];

    async function getStream(constraints) {
      if (navigator.mediaDevices?.getUserMedia) {
        return navigator.mediaDevices.getUserMedia(constraints);
      }
      return new Promise((resolve, reject) => legacyGetUserMedia.call(navigator, constraints, resolve, reject));
    }

    let lastError = null;
    for (const constraints of attempts) {
      try {
        stream = await getStream(constraints);
        if (!isStreamUsable(stream)) { stopCamera(); continue; }
        els.videoPreview.srcObject = stream;
        els.videoPreview.muted = true;
        els.videoPreview.autoplay = true;
        els.videoPreview.playsInline = true;
        els.videoPreview.setAttribute('playsinline', 'true');
        els.cameraSection.classList.remove('hidden');

        await new Promise((resolve) => {
          const timer = setTimeout(resolve, 3000);
          const done = () => { clearTimeout(timer); resolve(); };
          els.videoPreview.onloadedmetadata = done;
          els.videoPreview.onloadeddata = done;
        });

        try { await els.videoPreview.play(); } catch (_) { }
        const isPlayable = await waitForPlayable(els.videoPreview, 4000);
        if (!isPlayable) { stopCamera(); continue; }

        const hasFrame = await waitForVideoFrame(els.videoPreview, 4500);
        if (hasFrame) {
          await refreshCameraOptions();
          setCameraStatus('Camera ready.');
          setAppState(AppState.CAMERA_READY, 'Camera stream active.');
          setTimeout(() => setCameraStatus(''), 1500);
          return;
        }

        await new Promise((resolve) => setTimeout(resolve, 1500));
        const hasFrameRetry = await waitForVideoFrame(els.videoPreview, 3000);
        if (hasFrameRetry) {
          await refreshCameraOptions();
          setCameraStatus('Camera ready.');
          setAppState(AppState.CAMERA_READY, 'Camera stream active.');
          setTimeout(() => setCameraStatus(''), 1500);
          return;
        }
        stopCamera();
      } catch (err) {
        lastError = err;
      }
    }

    const errText = lastError ? ` (${lastError.name || 'Error'}${lastError.message ? `: ${lastError.message}` : ''})` : '';
    const secureHint = (location.protocol !== 'https:' && !['localhost','127.0.0.1'].includes(location.hostname)) ? ' Camera requires HTTPS on non-localhost origins.' : '';
    showWarning(`Unable to start camera stream. Check browser permissions, close other camera apps, and try again.${secureHint}${errText}`);
    setAppState(AppState.CAMERA_FAILED, 'Camera start failed. Try Open Camera (Compat) or verify site is HTTPS and permission is allowed.');
    runDiagnostics();
    setCameraStatus('');
    stopCamera();
  }

  function stopCamera(){
    setCameraStatus('');
    if(stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
    if (els.videoPreview) { els.videoPreview.pause(); els.videoPreview.srcObject = null; }
    els.cameraSection.classList.add('hidden');
    if (appState !== AppState.ANALYZING && appState !== AppState.ANALYSIS_READY) {
      appState = AppState.IDLE;
    }
  }

  function openFilePicker(){
    if (appState === AppState.REQUESTING_CAMERA || appState === AppState.ANALYZING) {
      setRuntimeStatus('Please wait for the current action to finish.');
      return;
    }
    setAppState(AppState.PICKER_OPENING, 'Opening file picker...');
    els.fileInput.value='';
    els.fileInput.click();
  }

  function isoRecommendations(category) {
    const controls = {
      slip: ['Eliminate spills and loose materials from walkways','Install anti-slip flooring or mats in high-traffic areas','Enforce housekeeping inspections every shift','Issue slip-resistant footwear'],
      visibility: ['Increase task lighting to recommended lux levels','Add reflective markings and warning signage','Introduce low-visibility work permit checks','Issue high-visibility PPE'],
      struck: ['Separate pedestrians and moving equipment paths','Add physical barriers and exclusion zones','Use spotters and traffic management plans','Issue head and eye protection'],
      ergonomic: ['Redesign workstation height/reach to neutral posture','Use mechanical aids for lifting/handling','Rotate repetitive tasks and add micro-breaks','Train workers in safe manual handling'],
      fireElectrical: ['Isolate damaged electrical/fire ignition sources immediately','Install/inspect circuit protection and emergency shutoffs','Apply permit-to-work and lockout/tagout controls','Issue insulated gloves and arc-rated PPE']
    };
    return controls[category] || ['Apply hierarchy of controls: eliminate, engineer, administrate, PPE','Conduct supervisor-led job safety analysis'];
  }

  function heuristicHazardsFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    const img = ctx.getImageData(0, 0, width, height).data;
    let sum = 0, edge = 0;
    for (let i = 0; i < img.length; i += 16) {
      const v = (img[i] + img[i+1] + img[i+2]) / 3;
      sum += v;
      if (i > 16) {
        const pv = (img[i-16] + img[i-15] + img[i-14]) / 3;
        if (Math.abs(v - pv) > 45) edge++;
      }
    }
    const samples = Math.floor(img.length / 16);
    const avg = sum / Math.max(samples, 1);
    const edgeRatio = edge / Math.max(samples, 1);

    const out = [];
    if (avg < 85) out.push({name:'Low Visibility / Poor Illumination',L:3,S:3,risk:9,conf:0.72,recs:isoRecommendations('visibility')});
    if (edgeRatio > 0.22) out.push({name:'Slip/Trip Obstruction',L:3,S:3,risk:9,conf:0.69,recs:isoRecommendations('slip')});
    if (out.length === 0) out.push({name:'General Task Hazard Review Required',L:2,S:2,risk:4,conf:0.65,recs:['Conduct a task-specific ISO 45001 hazard identification review','Confirm controls with competent supervisor before work']});
    return out;
  }

  function hazardsFromPredictions(preds) {
    const labelText = preds.map(p => `${p.className.toLowerCase()} ${(p.probability || 0).toFixed(3)}`).join(' | ');
    const profiles = [
      {name:'Struck-by / Vehicle Interaction', category:'struck', keys:['truck','car','bus','forklift','machine','tractor','vehicle'], L:3, S:4},
      {name:'Ergonomic / Manual Handling', category:'ergonomic', keys:['person','worker','uniform','backpack','carton','box'], L:3, S:3},
      {name:'Electrical / Fire Potential', category:'fireElectrical', keys:['wire','cable','electric','plug','switch','generator','engine'], L:2, S:5},
      {name:'Slip/Trip Surface Condition', category:'slip', keys:['floor','stairs','ladder','corridor','warehouse','platform'], L:3, S:3}
    ];

    const out = [];
    profiles.forEach((p) => {
      const strength = p.keys.reduce((acc, key) => {
        const hit = preds.find(pr => pr.className.toLowerCase().includes(key));
        return acc + (hit ? hit.probability : 0);
      }, 0);
      if (strength >= 0.15) {
        const likelihoodBoost = strength > 0.55 ? 1 : 0;
        const L = Math.min(5, p.L + likelihoodBoost);
        const S = p.S;
        out.push({
          name: p.name,
          L,
          S,
          risk: L * S,
          conf: Math.min(0.95, Math.max(0.55, strength)),
          recs: isoRecommendations(p.category)
        });
      }
    });

    if (out.length === 0 && labelText.includes('person')) {
      out.push({name:'Behavioral / Human-factor Exposure', L:2, S:3, risk:6, conf:0.6, recs:['Verify task briefing and supervision','Ensure competency and permit-to-work compliance','Confirm required PPE is worn correctly']});
    }
    return out;
  }

  function mapPredictions(preds){
    const found = new Set();
    const out = [];
    preds.forEach(p => {
      const name = p.className.toLowerCase();
      Object.entries(hazardDB).forEach(([key,h]) => {
        h.kw.forEach(kw => {
          if(name.includes(kw) && !found.has(key)) {
            found.add(key);
            out.push({name:h.name,L:h.L,S:h.S,risk:h.L*h.S,conf:p.probability,recs:h.recs});
          }
        });
      });
    });
    return out;
  }

  function render(){
    els.results.classList.remove('hidden');
    els.resultImg.src = imageData;
    els.fallbackWarning.classList.toggle('hidden', !usedFallback);

    overall = hazards.length ? Math.max(...hazards.map(h => h.risk)) : 0;
    const r = riskFor(overall);
    els.overallScore.textContent = String(overall);
    els.overallLevel.textContent = r.label;
    els.overallLevel.style.background = r.color;

    els.hazardsList.textContent = '';
    hazards.forEach(h => {
      const hr = riskFor(h.risk);
      const item = document.createElement('div');
      item.className = `hazard-item ${hr.cls}`;
      const t = document.createElement('div');
      t.textContent = `${h.name} (${Math.round((h.conf||0)*100)}%)`;
      const d = document.createElement('div');
      d.textContent = `Likelihood ${h.L}, Severity ${h.S}, Risk ${h.risk} (${hr.label.replace(' Risk','')})`;
      item.append(t,d);
      els.hazardsList.appendChild(item);
    });

    els.riskMatrix.textContent = '';
    const add = (txt, cls) => { const c = document.createElement('div'); c.className = `cell ${cls}`; c.textContent = txt; els.riskMatrix.appendChild(c); };
    add('', ''); [1,2,3,4,5].forEach(s => add(`S${s}`, 'head'));
    for(let l=1;l<=5;l++){
      add(`L${l}`, 'head');
      for(let s=1;s<=5;s++){
        const score=l*s; const c=document.createElement('div');
        let cls='low'; if(score>=20)cls='ext'; else if(score>=15)cls='high'; else if(score>=6)cls='med';
        c.className=`cell ${cls}${hazards.some(h=>h.risk===score)?' mark':''}`;
        c.textContent=String(score);
        els.riskMatrix.appendChild(c);
      }
    }

    els.recsList.textContent = '';
    const recs = [...new Set(hazards.flatMap(h => h.recs || []))];
    recs.forEach(rec => { const p = document.createElement('p'); p.textContent = `â€¢ ${rec}`; els.recsList.appendChild(p); });
  }

  async function analyze(dataUrl){
    setAppState(AppState.ANALYZING, 'Analyzing image...');
    setLoading(true);
    try {
      imageData = dataUrl;
      hazards = [];

      const img = new Image();
      await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = dataUrl; });
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      canvas.getContext('2d').drawImage(img, 0, 0);

      if (model) {
        try {
          const preds = await model.classify(img);
          hazards = mapPredictions(preds);
          if (hazards.length === 0) {
            hazards = hazardsFromPredictions(preds);
          }
        } catch {
          usedFallback = true;
        }
      }

      if (hazards.length === 0) {
        hazards = heuristicHazardsFromCanvas(canvas);
      }

      render();
      setAppState(AppState.ANALYSIS_READY, 'Analysis complete.');
    } catch {
      usedFallback = true;
      hazards = [{name:'General Workplace Hazard',L:2,S:2,risk:4,conf:0.5,recs:['Run manual inspection','Repeat assessment with clearer image']}];
      render();
      setAppState(AppState.ANALYSIS_FAILED, 'Analysis failed. Showing fallback results.');
    } finally {
      setLoading(false);
    }
  }

  function exportReport(){
    const risk = riskFor(overall).label;
    let out = `HSE Risk Assessment\nDate: ${new Date().toISOString()}\nRisk: ${risk} (${overall}/25)\nHeuristic Mode: ${usedFallback?'YES':'NO'}\n\nHazards:\n`;
    hazards.forEach((h,i)=> out += `${i+1}. ${h.name} | L=${h.L} S=${h.S} Risk=${h.risk}\n`);
    out += `\nRecommendations:\n${[...new Set(hazards.flatMap(h=>h.recs||[]))].map((r,i)=>`${i+1}. ${r}`).join('\n')}`;
    const blob = new Blob([out], {type:'text/plain'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a');
    a.href = url; a.download = `HSE_Risk_Assessment_${new Date().toISOString().slice(0,10)}.txt`; a.click(); URL.revokeObjectURL(url);
  }

  function resetApp(){ stopCamera(); hazards=[]; overall=0; imageData=null; usedFallback=false; els.fileInput.value=''; els.results.classList.add('hidden'); }

  function captureFromCamera(){
    if (!els.videoPreview.videoWidth || !els.videoPreview.videoHeight) {
      showWarning('No camera frame available yet. Try switching camera, then retry capture.');
      return;
    }
    const c=document.createElement('canvas');
    c.width=els.videoPreview.videoWidth;
    c.height=els.videoPreview.videoHeight;
    c.getContext('2d').drawImage(els.videoPreview,0,0);
    stopCamera();
    analyze(c.toDataURL('image/jpeg',0.9));
  }

  els.btnCamera.addEventListener('click', startCamera);
  els.btnUpload.addEventListener('click', openFilePicker);
  els.btnCapture.addEventListener('click', captureFromCamera);
  els.btnStop.addEventListener('click', stopCamera);
  els.cameraSelect.addEventListener('change', () => { selectedDeviceId = els.cameraSelect.value; });
  els.btnSwitchCam.addEventListener('click', () => {
    preferredFacingMode = preferredFacingMode === 'environment' ? 'user' : 'environment';
    selectedDeviceId = '';
    els.cameraSelect.value = '';
    startCamera();
  });
  els.btnCameraBasic.addEventListener('click', () => {
    // CAMERA_STABILITY_LOCK: explicit compatibility mode using minimal constraints only.
    selectedDeviceId = '';
    els.cameraSelect.value = '';
    startCamera({ forceBasic: true });
  });
  els.btnDiagnose.addEventListener('click', runDiagnostics);
  els.btnCopyDiag.addEventListener('click', copyDiagnostics);
  els.btnExport.addEventListener('click', exportReport);
  els.btnReset.addEventListener('click', resetApp);
  els.fileInput.addEventListener('change', (e) => {
    const f = e.target.files?.[0];
    if(!f) { setAppState(AppState.IDLE, 'No file selected.'); return; }
    setAppState(AppState.IMAGE_SELECTED, `Selected file: ${f.name || 'image'}`);
    const name = (f.name || '').toLowerCase();
    const looksImage = (f.type && f.type.startsWith('image/')) || /\.(png|jpe?g|webp|gif|bmp|heic|heif)$/i.test(name);
    if(!looksImage) { showWarning('Please upload a valid image file.'); e.target.value=''; return; }
    const reader = new FileReader();
    reader.onload = (ev) => { setRuntimeStatus('Image loaded. Running analysis...'); analyze(ev.target.result); };
    reader.onerror = () => showWarning('Failed to read selected image.');
    reader.readAsDataURL(f);
  });
  els.uploadArea.addEventListener('click', openFilePicker);
  els.uploadArea.addEventListener('keydown', (e) => { if(e.key==='Enter' || e.key===' '){ e.preventDefault(); openFilePicker(); }});

  window.openFilePicker = openFilePicker;
  window.startCam = startCamera;
  window.stopCam = stopCamera;
  window.capture = captureFromCamera;
  window.analyze = analyze;
  window.exportReport = exportReport;
  window.resetApp = resetApp;
  window.getAppState = () => appState;
  window.runDiagnostics = runDiagnostics;
  window.copyDiagnostics = copyDiagnostics;

  window.addEventListener('error', (ev) => { showWarning(`Runtime error: ${ev.message || 'unknown error'}`); setRuntimeStatus('A script error occurred. Reload and retry.'); });
  window.addEventListener('unhandledrejection', (ev) => { showWarning(`Unhandled error: ${ev.reason?.message || ev.reason || 'promise rejection'}`); });
  initModel();
  refreshCameraOptions();
})();
</script>
</body>
</html>
